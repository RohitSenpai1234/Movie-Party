{"ast":null,"code":"var _s = $RefreshSig$();\n/**\r\n * useVideoSync.js\r\n *\r\n * Handles play/pause/seek synchronization between host and viewers.\r\n *\r\n * Sync algorithm:\r\n *  1. Host emits sync-heartbeat every 5 s: { playing, currentTime, serverTime }\r\n *  2. Viewer measures RTT via periodic ping/pong with the server.\r\n *  3. expectedViewerTime = currentTime + (rtt / 2 / 1000)\r\n *  4. If drift > HARD_SEEK_THRESHOLD → hard seek (snap).\r\n *  5. If drift in (SOFT_ADJUST_MIN, HARD_SEEK_THRESHOLD) → tweak playbackRate by ±0.05.\r\n *\r\n * Usage (host):\r\n *   const { emitPlay, emitPause, emitSeek, startHeartbeat, stopHeartbeat } =\r\n *     useVideoSync({ socket, roomId, videoRef, isHost: true });\r\n *\r\n * Usage (viewer):\r\n *   const { startHeartbeat, stopHeartbeat } =\r\n *     useVideoSync({ socket, roomId, videoRef, isHost: false });\r\n */\n\nimport { useRef, useCallback, useEffect, useState } from \"react\";\nconst HEARTBEAT_INTERVAL_MS = 5000;\nconst HARD_SEEK_THRESHOLD_S = 0.8; // >0.8 s drift → hard seek\nconst SOFT_ADJUST_MIN_S = 0.15; // 0.15–0.8 s drift → rate tweak\nconst RATE_ADJUST_STEP = 0.05; // playbackRate offset to apply\nconst SEEK_DEBOUNCE_MS = 150;\nexport function useVideoSync({\n  socket,\n  roomId,\n  videoRef,\n  isHost\n}) {\n  _s();\n  const heartbeatInterval = useRef(null);\n  const rttRef = useRef(0); // measured RTT in ms\n  const seekDebounceRef = useRef(null);\n  const isSyncingRef = useRef(false); // prevent event re-entrant loops\n  const pingIntervalRef = useRef(null);\n\n  // State for UI to consume\n  const [roomTime, setRoomTime] = useState(0);\n  const [roomDuration, setRoomDuration] = useState(0);\n\n  // Host/Viewer track time in state for simpler UI consumption\n  const lastSyncRef = useRef({\n    playing: false,\n    currentTime: 0,\n    serverTime: 0,\n    duration: 0\n  });\n  const getCleanRoomId = useCallback(() => roomId ? roomId.trim().toUpperCase() : \"\", [roomId]);\n\n  // ── RTT measurement (every 10 s) ────────────────────────────────────────\n  const startRttMeasurement = useCallback(() => {\n    if (pingIntervalRef.current) return;\n    const measure = () => {\n      const t0 = Date.now();\n      socket.emit(\"ping-rtt\", t0);\n      const handle = socket.once(\"pong-rtt\", sentTime => {\n        if (sentTime === t0) {\n          rttRef.current = Date.now() - t0;\n          console.log(`[Sync] RTT: ${rttRef.current} ms`);\n        }\n      });\n      // Safety cleanup in case pong never arrives\n      setTimeout(() => socket.off(\"pong-rtt\", handle), 5000);\n    };\n    measure(); // immediate first measurement\n    pingIntervalRef.current = setInterval(measure, 10000);\n  }, [socket]);\n  const stopRttMeasurement = useCallback(() => {\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n      pingIntervalRef.current = null;\n    }\n  }, []);\n\n  // ── Apply sync to viewer's video element ────────────────────────────────\n  const applySyncToViewer = useCallback(({\n    playing,\n    currentTime,\n    serverTime,\n    duration\n  }) => {\n    const video = videoRef.current;\n    if (!video || isHost) return;\n\n    // Store for interpolation\n    lastSyncRef.current = {\n      playing,\n      currentTime,\n      serverTime,\n      duration\n    };\n    setRoomDuration(duration || 0);\n\n    // Compute expected time accounting for one-way latency\n    const oneWayLatency = rttRef.current / 2 / 1000; // seconds\n    const elapsed = (Date.now() - serverTime) / 1000;\n    const expectedTime = currentTime + oneWayLatency + elapsed;\n    const drift = expectedTime - video.currentTime;\n    console.log(`[Sync] drift=${drift.toFixed(3)}s  expected=${expectedTime.toFixed(2)}  actual=${video.currentTime.toFixed(2)}`);\n    isSyncingRef.current = true;\n\n    // — Hard seek —\n    if (Math.abs(drift) > HARD_SEEK_THRESHOLD_S) {\n      console.log(`[Sync] Hard seek → ${expectedTime.toFixed(2)} s`);\n      video.currentTime = expectedTime;\n      video.playbackRate = 1.0;\n    }\n    // — Soft rate adjustment —\n    else if (Math.abs(drift) > SOFT_ADJUST_MIN_S) {\n      const rate = drift > 0 ? 1.0 + RATE_ADJUST_STEP : 1.0 - RATE_ADJUST_STEP;\n      console.log(`[Sync] Rate adjust → ${rate}`);\n      video.playbackRate = rate;\n    }\n    // — Already in sync —\n    else {\n      video.playbackRate = 1.0;\n    }\n\n    // Apply play/pause state\n    if (playing && video.paused) {\n      video.play().catch(() => {});\n    } else if (!playing && !video.paused) {\n      video.pause();\n    }\n\n    // Allow normal events again after the DOM has settled\n    setTimeout(() => {\n      isSyncingRef.current = false;\n    }, 250);\n  }, [videoRef, isHost]);\n\n  // ── Host: start broadcasting heartbeat ─────────────────────────────────\n  const startHeartbeat = useCallback(() => {\n    if (!isHost || heartbeatInterval.current) return;\n    startRttMeasurement();\n    heartbeatInterval.current = setInterval(() => {\n      const video = videoRef.current;\n      if (!video) return;\n      const duration = video.duration || 0;\n      const currentTime = video.currentTime || 0;\n      const playing = !video.paused;\n      socket.emit(\"sync-heartbeat\", {\n        roomId: getCleanRoomId(),\n        playing,\n        currentTime,\n        duration\n      });\n\n      // Update local state for host UI (heartbeat is just for others, state is for local UI)\n      setRoomTime(currentTime);\n      setRoomDuration(duration);\n    }, HEARTBEAT_INTERVAL_MS);\n    console.log(\"[Sync] Heartbeat started\");\n  }, [isHost, socket, videoRef, getCleanRoomId, startRttMeasurement]);\n\n  // ── Host-only real-time tracking (for local UI smoothness) ──────────────\n  useEffect(() => {\n    if (!isHost) return;\n    const video = videoRef.current;\n    if (!video) return;\n    const onTimeUpdate = () => {\n      setRoomTime(video.currentTime);\n    };\n    const onLoadedMetadata = () => {\n      setRoomDuration(video.duration);\n    };\n    video.addEventListener(\"timeupdate\", onTimeUpdate);\n    video.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n\n    // Initial capture\n    if (video.duration) setRoomDuration(video.duration);\n    return () => {\n      video.removeEventListener(\"timeupdate\", onTimeUpdate);\n      video.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n    };\n  }, [isHost, videoRef]);\n  const stopHeartbeat = useCallback(() => {\n    if (heartbeatInterval.current) {\n      clearInterval(heartbeatInterval.current);\n      heartbeatInterval.current = null;\n    }\n    stopRttMeasurement();\n    console.log(\"[Sync] Heartbeat stopped\");\n  }, [stopRttMeasurement]);\n\n  // ── Host: emit play/pause/seek ──────────────────────────────────────────\n  const emitPlay = useCallback(() => {\n    if (!isHost) return;\n    socket.emit(\"play-video\", getCleanRoomId());\n  }, [isHost, socket, getCleanRoomId]);\n  const emitPause = useCallback(() => {\n    if (!isHost) return;\n    socket.emit(\"pause-video\", getCleanRoomId());\n  }, [isHost, socket, getCleanRoomId]);\n  const emitSeek = useCallback(time => {\n    if (!isHost) return;\n    if (seekDebounceRef.current) clearTimeout(seekDebounceRef.current);\n    seekDebounceRef.current = setTimeout(() => {\n      socket.emit(\"seek-video\", {\n        roomId: getCleanRoomId(),\n        time\n      });\n      // Also send an immediate heartbeat so viewers snap to the right position\n      const video = videoRef.current;\n      if (video) {\n        socket.emit(\"sync-heartbeat\", {\n          roomId: getCleanRoomId(),\n          playing: !video.paused,\n          currentTime: video.currentTime,\n          duration: video.duration || 0\n        });\n      }\n    }, SEEK_DEBOUNCE_MS);\n  }, [isHost, socket, videoRef, getCleanRoomId]);\n  const emitVolumeChange = useCallback(({\n    muted,\n    volume\n  }) => {\n    if (!isHost) return;\n    socket.emit(\"volume-change\", {\n      roomId: getCleanRoomId(),\n      muted,\n      volume\n    });\n  }, [isHost, socket, getCleanRoomId]);\n\n  // ── Viewer: listen for sync events ─────────────────────────────────────\n  useEffect(() => {\n    if (!socket) return;\n    if (!isHost) {\n      startRttMeasurement();\n    }\n    const handleHeartbeat = payload => applySyncToViewer(payload);\n    const handlePlay = () => {\n      if (isHost || isSyncingRef.current) return;\n      const video = videoRef.current;\n      if (video && video.paused) {\n        isSyncingRef.current = true;\n        video.play().catch(() => {}).finally(() => {\n          isSyncingRef.current = false;\n        });\n      }\n    };\n    const handlePause = () => {\n      if (isHost || isSyncingRef.current) return;\n      const video = videoRef.current;\n      if (video && !video.paused) {\n        isSyncingRef.current = true;\n        video.pause();\n        setTimeout(() => {\n          isSyncingRef.current = false;\n        }, 100);\n      }\n    };\n    const handleSeek = time => {\n      if (isHost || isSyncingRef.current) return;\n      const video = videoRef.current;\n      if (!video) return;\n      isSyncingRef.current = true;\n      if (seekDebounceRef.current) clearTimeout(seekDebounceRef.current);\n      seekDebounceRef.current = setTimeout(() => {\n        video.currentTime = time;\n        setTimeout(() => {\n          isSyncingRef.current = false;\n        }, 200);\n      }, 80);\n    };\n    const handleVolumeChange = ({\n      muted,\n      volume\n    }) => {\n      if (isHost) return;\n      const video = videoRef.current;\n      if (!video) return;\n      video.muted = muted;\n      if (!muted && typeof volume === \"number\") video.volume = volume;\n    };\n    socket.on(\"sync-heartbeat\", handleHeartbeat);\n    socket.on(\"play-video\", handlePlay);\n    socket.on(\"pause-video\", handlePause);\n    socket.on(\"seek-video\", handleSeek);\n    socket.on(\"volume-change\", handleVolumeChange);\n    return () => {\n      socket.off(\"sync-heartbeat\", handleHeartbeat);\n      socket.off(\"play-video\", handlePlay);\n      socket.off(\"pause-video\", handlePause);\n      socket.off(\"seek-video\", handleSeek);\n      socket.off(\"volume-change\", handleVolumeChange);\n      if (!isHost) stopRttMeasurement();\n    };\n  }, [socket, isHost, videoRef, applySyncToViewer, startRttMeasurement, stopRttMeasurement]);\n\n  // ── Interpolate roomTime for viewers ────────────────────────────────────\n  useEffect(() => {\n    if (isHost) return;\n    const timer = setInterval(() => {\n      const {\n        playing,\n        currentTime,\n        serverTime\n      } = lastSyncRef.current;\n      if (!playing) {\n        setRoomTime(currentTime);\n        return;\n      }\n      const oneWayLatency = rttRef.current / 2 / 1000;\n      const elapsedSinceSync = (Date.now() - serverTime) / 1000;\n      setRoomTime(currentTime + oneWayLatency + elapsedSinceSync);\n    }, 100);\n    return () => clearInterval(timer);\n  }, [isHost]);\n\n  // ── Cleanup ─────────────────────────────────────────────────────────────\n  useEffect(() => {\n    return () => {\n      stopHeartbeat();\n      if (seekDebounceRef.current) clearTimeout(seekDebounceRef.current);\n    };\n  }, [stopHeartbeat]);\n  return {\n    emitPlay,\n    emitPause,\n    emitSeek,\n    emitVolumeChange,\n    startHeartbeat,\n    stopHeartbeat,\n    roomTime,\n    roomDuration,\n    isSyncing: () => isSyncingRef.current\n  };\n}\n_s(useVideoSync, \"xndg4YjxU0VSb5brAe1BaWAfsw8=\");","map":{"version":3,"names":["useRef","useCallback","useEffect","useState","HEARTBEAT_INTERVAL_MS","HARD_SEEK_THRESHOLD_S","SOFT_ADJUST_MIN_S","RATE_ADJUST_STEP","SEEK_DEBOUNCE_MS","useVideoSync","socket","roomId","videoRef","isHost","_s","heartbeatInterval","rttRef","seekDebounceRef","isSyncingRef","pingIntervalRef","roomTime","setRoomTime","roomDuration","setRoomDuration","lastSyncRef","playing","currentTime","serverTime","duration","getCleanRoomId","trim","toUpperCase","startRttMeasurement","current","measure","t0","Date","now","emit","handle","once","sentTime","console","log","setTimeout","off","setInterval","stopRttMeasurement","clearInterval","applySyncToViewer","video","oneWayLatency","elapsed","expectedTime","drift","toFixed","Math","abs","playbackRate","rate","paused","play","catch","pause","startHeartbeat","onTimeUpdate","onLoadedMetadata","addEventListener","removeEventListener","stopHeartbeat","emitPlay","emitPause","emitSeek","time","clearTimeout","emitVolumeChange","muted","volume","handleHeartbeat","payload","handlePlay","finally","handlePause","handleSeek","handleVolumeChange","on","timer","elapsedSinceSync","isSyncing"],"sources":["C:/Users/rohit/OneDrive/Desktop/SrtreamMovie/Movie-Party/frontend/src/hooks/useVideoSync.js"],"sourcesContent":["/**\r\n * useVideoSync.js\r\n *\r\n * Handles play/pause/seek synchronization between host and viewers.\r\n *\r\n * Sync algorithm:\r\n *  1. Host emits sync-heartbeat every 5 s: { playing, currentTime, serverTime }\r\n *  2. Viewer measures RTT via periodic ping/pong with the server.\r\n *  3. expectedViewerTime = currentTime + (rtt / 2 / 1000)\r\n *  4. If drift > HARD_SEEK_THRESHOLD → hard seek (snap).\r\n *  5. If drift in (SOFT_ADJUST_MIN, HARD_SEEK_THRESHOLD) → tweak playbackRate by ±0.05.\r\n *\r\n * Usage (host):\r\n *   const { emitPlay, emitPause, emitSeek, startHeartbeat, stopHeartbeat } =\r\n *     useVideoSync({ socket, roomId, videoRef, isHost: true });\r\n *\r\n * Usage (viewer):\r\n *   const { startHeartbeat, stopHeartbeat } =\r\n *     useVideoSync({ socket, roomId, videoRef, isHost: false });\r\n */\r\n\r\nimport { useRef, useCallback, useEffect, useState } from \"react\";\r\n\r\nconst HEARTBEAT_INTERVAL_MS = 5000;\r\nconst HARD_SEEK_THRESHOLD_S = 0.8;   // >0.8 s drift → hard seek\r\nconst SOFT_ADJUST_MIN_S = 0.15;      // 0.15–0.8 s drift → rate tweak\r\nconst RATE_ADJUST_STEP = 0.05;       // playbackRate offset to apply\r\nconst SEEK_DEBOUNCE_MS = 150;\r\n\r\nexport function useVideoSync({ socket, roomId, videoRef, isHost }) {\r\n    const heartbeatInterval = useRef(null);\r\n    const rttRef = useRef(0);           // measured RTT in ms\r\n    const seekDebounceRef = useRef(null);\r\n    const isSyncingRef = useRef(false); // prevent event re-entrant loops\r\n    const pingIntervalRef = useRef(null);\r\n\r\n    // State for UI to consume\r\n    const [roomTime, setRoomTime] = useState(0);\r\n    const [roomDuration, setRoomDuration] = useState(0);\r\n\r\n    // Host/Viewer track time in state for simpler UI consumption\r\n    const lastSyncRef = useRef({ playing: false, currentTime: 0, serverTime: 0, duration: 0 });\r\n\r\n    const getCleanRoomId = useCallback(\r\n        () => (roomId ? roomId.trim().toUpperCase() : \"\"),\r\n        [roomId]\r\n    );\r\n\r\n    // ── RTT measurement (every 10 s) ────────────────────────────────────────\r\n    const startRttMeasurement = useCallback(() => {\r\n        if (pingIntervalRef.current) return;\r\n\r\n        const measure = () => {\r\n            const t0 = Date.now();\r\n            socket.emit(\"ping-rtt\", t0);\r\n            const handle = socket.once(\"pong-rtt\", (sentTime) => {\r\n                if (sentTime === t0) {\r\n                    rttRef.current = Date.now() - t0;\r\n                    console.log(`[Sync] RTT: ${rttRef.current} ms`);\r\n                }\r\n            });\r\n            // Safety cleanup in case pong never arrives\r\n            setTimeout(() => socket.off(\"pong-rtt\", handle), 5000);\r\n        };\r\n\r\n        measure(); // immediate first measurement\r\n        pingIntervalRef.current = setInterval(measure, 10000);\r\n    }, [socket]);\r\n\r\n    const stopRttMeasurement = useCallback(() => {\r\n        if (pingIntervalRef.current) {\r\n            clearInterval(pingIntervalRef.current);\r\n            pingIntervalRef.current = null;\r\n        }\r\n    }, []);\r\n\r\n    // ── Apply sync to viewer's video element ────────────────────────────────\r\n    const applySyncToViewer = useCallback(\r\n        ({ playing, currentTime, serverTime, duration }) => {\r\n            const video = videoRef.current;\r\n            if (!video || isHost) return;\r\n\r\n            // Store for interpolation\r\n            lastSyncRef.current = { playing, currentTime, serverTime, duration };\r\n            setRoomDuration(duration || 0);\r\n\r\n            // Compute expected time accounting for one-way latency\r\n            const oneWayLatency = rttRef.current / 2 / 1000; // seconds\r\n            const elapsed = (Date.now() - serverTime) / 1000;\r\n            const expectedTime = currentTime + oneWayLatency + elapsed;\r\n\r\n            const drift = expectedTime - video.currentTime;\r\n            console.log(\r\n                `[Sync] drift=${drift.toFixed(3)}s  expected=${expectedTime.toFixed(2)}  actual=${video.currentTime.toFixed(2)}`\r\n            );\r\n\r\n            isSyncingRef.current = true;\r\n\r\n            // — Hard seek —\r\n            if (Math.abs(drift) > HARD_SEEK_THRESHOLD_S) {\r\n                console.log(`[Sync] Hard seek → ${expectedTime.toFixed(2)} s`);\r\n                video.currentTime = expectedTime;\r\n                video.playbackRate = 1.0;\r\n            }\r\n            // — Soft rate adjustment —\r\n            else if (Math.abs(drift) > SOFT_ADJUST_MIN_S) {\r\n                const rate = drift > 0 ? 1.0 + RATE_ADJUST_STEP : 1.0 - RATE_ADJUST_STEP;\r\n                console.log(`[Sync] Rate adjust → ${rate}`);\r\n                video.playbackRate = rate;\r\n            }\r\n            // — Already in sync —\r\n            else {\r\n                video.playbackRate = 1.0;\r\n            }\r\n\r\n            // Apply play/pause state\r\n            if (playing && video.paused) {\r\n                video.play().catch(() => { });\r\n            } else if (!playing && !video.paused) {\r\n                video.pause();\r\n            }\r\n\r\n            // Allow normal events again after the DOM has settled\r\n            setTimeout(() => {\r\n                isSyncingRef.current = false;\r\n            }, 250);\r\n        },\r\n        [videoRef, isHost]\r\n    );\r\n\r\n    // ── Host: start broadcasting heartbeat ─────────────────────────────────\r\n    const startHeartbeat = useCallback(() => {\r\n        if (!isHost || heartbeatInterval.current) return;\r\n        startRttMeasurement();\r\n\r\n        heartbeatInterval.current = setInterval(() => {\r\n            const video = videoRef.current;\r\n            if (!video) return;\r\n            const duration = video.duration || 0;\r\n            const currentTime = video.currentTime || 0;\r\n            const playing = !video.paused;\r\n\r\n            socket.emit(\"sync-heartbeat\", {\r\n                roomId: getCleanRoomId(),\r\n                playing,\r\n                currentTime,\r\n                duration,\r\n            });\r\n\r\n            // Update local state for host UI (heartbeat is just for others, state is for local UI)\r\n            setRoomTime(currentTime);\r\n            setRoomDuration(duration);\r\n        }, HEARTBEAT_INTERVAL_MS);\r\n\r\n        console.log(\"[Sync] Heartbeat started\");\r\n    }, [isHost, socket, videoRef, getCleanRoomId, startRttMeasurement]);\r\n\r\n    // ── Host-only real-time tracking (for local UI smoothness) ──────────────\r\n    useEffect(() => {\r\n        if (!isHost) return;\r\n        const video = videoRef.current;\r\n        if (!video) return;\r\n\r\n        const onTimeUpdate = () => {\r\n            setRoomTime(video.currentTime);\r\n        };\r\n        const onLoadedMetadata = () => {\r\n            setRoomDuration(video.duration);\r\n        };\r\n\r\n        video.addEventListener(\"timeupdate\", onTimeUpdate);\r\n        video.addEventListener(\"loadedmetadata\", onLoadedMetadata);\r\n\r\n        // Initial capture\r\n        if (video.duration) setRoomDuration(video.duration);\r\n\r\n        return () => {\r\n            video.removeEventListener(\"timeupdate\", onTimeUpdate);\r\n            video.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\r\n        };\r\n    }, [isHost, videoRef]);\r\n\r\n    const stopHeartbeat = useCallback(() => {\r\n        if (heartbeatInterval.current) {\r\n            clearInterval(heartbeatInterval.current);\r\n            heartbeatInterval.current = null;\r\n        }\r\n        stopRttMeasurement();\r\n        console.log(\"[Sync] Heartbeat stopped\");\r\n    }, [stopRttMeasurement]);\r\n\r\n    // ── Host: emit play/pause/seek ──────────────────────────────────────────\r\n    const emitPlay = useCallback(() => {\r\n        if (!isHost) return;\r\n        socket.emit(\"play-video\", getCleanRoomId());\r\n    }, [isHost, socket, getCleanRoomId]);\r\n\r\n    const emitPause = useCallback(() => {\r\n        if (!isHost) return;\r\n        socket.emit(\"pause-video\", getCleanRoomId());\r\n    }, [isHost, socket, getCleanRoomId]);\r\n\r\n    const emitSeek = useCallback(\r\n        (time) => {\r\n            if (!isHost) return;\r\n            if (seekDebounceRef.current) clearTimeout(seekDebounceRef.current);\r\n            seekDebounceRef.current = setTimeout(() => {\r\n                socket.emit(\"seek-video\", { roomId: getCleanRoomId(), time });\r\n                // Also send an immediate heartbeat so viewers snap to the right position\r\n                const video = videoRef.current;\r\n                if (video) {\r\n                    socket.emit(\"sync-heartbeat\", {\r\n                        roomId: getCleanRoomId(),\r\n                        playing: !video.paused,\r\n                        currentTime: video.currentTime,\r\n                        duration: video.duration || 0,\r\n                    });\r\n                }\r\n            }, SEEK_DEBOUNCE_MS);\r\n        },\r\n        [isHost, socket, videoRef, getCleanRoomId]\r\n    );\r\n\r\n    const emitVolumeChange = useCallback(\r\n        ({ muted, volume }) => {\r\n            if (!isHost) return;\r\n            socket.emit(\"volume-change\", { roomId: getCleanRoomId(), muted, volume });\r\n        },\r\n        [isHost, socket, getCleanRoomId]\r\n    );\r\n\r\n    // ── Viewer: listen for sync events ─────────────────────────────────────\r\n    useEffect(() => {\r\n        if (!socket) return;\r\n\r\n        if (!isHost) {\r\n            startRttMeasurement();\r\n        }\r\n\r\n        const handleHeartbeat = (payload) => applySyncToViewer(payload);\r\n\r\n        const handlePlay = () => {\r\n            if (isHost || isSyncingRef.current) return;\r\n            const video = videoRef.current;\r\n            if (video && video.paused) {\r\n                isSyncingRef.current = true;\r\n                video.play().catch(() => { }).finally(() => {\r\n                    isSyncingRef.current = false;\r\n                });\r\n            }\r\n        };\r\n\r\n        const handlePause = () => {\r\n            if (isHost || isSyncingRef.current) return;\r\n            const video = videoRef.current;\r\n            if (video && !video.paused) {\r\n                isSyncingRef.current = true;\r\n                video.pause();\r\n                setTimeout(() => { isSyncingRef.current = false; }, 100);\r\n            }\r\n        };\r\n\r\n        const handleSeek = (time) => {\r\n            if (isHost || isSyncingRef.current) return;\r\n            const video = videoRef.current;\r\n            if (!video) return;\r\n            isSyncingRef.current = true;\r\n            if (seekDebounceRef.current) clearTimeout(seekDebounceRef.current);\r\n            seekDebounceRef.current = setTimeout(() => {\r\n                video.currentTime = time;\r\n                setTimeout(() => { isSyncingRef.current = false; }, 200);\r\n            }, 80);\r\n        };\r\n\r\n        const handleVolumeChange = ({ muted, volume }) => {\r\n            if (isHost) return;\r\n            const video = videoRef.current;\r\n            if (!video) return;\r\n            video.muted = muted;\r\n            if (!muted && typeof volume === \"number\") video.volume = volume;\r\n        };\r\n\r\n        socket.on(\"sync-heartbeat\", handleHeartbeat);\r\n        socket.on(\"play-video\", handlePlay);\r\n        socket.on(\"pause-video\", handlePause);\r\n        socket.on(\"seek-video\", handleSeek);\r\n        socket.on(\"volume-change\", handleVolumeChange);\r\n\r\n        return () => {\r\n            socket.off(\"sync-heartbeat\", handleHeartbeat);\r\n            socket.off(\"play-video\", handlePlay);\r\n            socket.off(\"pause-video\", handlePause);\r\n            socket.off(\"seek-video\", handleSeek);\r\n            socket.off(\"volume-change\", handleVolumeChange);\r\n            if (!isHost) stopRttMeasurement();\r\n        };\r\n    }, [socket, isHost, videoRef, applySyncToViewer, startRttMeasurement, stopRttMeasurement]);\r\n\r\n    // ── Interpolate roomTime for viewers ────────────────────────────────────\r\n    useEffect(() => {\r\n        if (isHost) return;\r\n        const timer = setInterval(() => {\r\n            const { playing, currentTime, serverTime } = lastSyncRef.current;\r\n            if (!playing) {\r\n                setRoomTime(currentTime);\r\n                return;\r\n            }\r\n            const oneWayLatency = rttRef.current / 2 / 1000;\r\n            const elapsedSinceSync = (Date.now() - serverTime) / 1000;\r\n            setRoomTime(currentTime + oneWayLatency + elapsedSinceSync);\r\n        }, 100);\r\n\r\n        return () => clearInterval(timer);\r\n    }, [isHost]);\r\n\r\n    // ── Cleanup ─────────────────────────────────────────────────────────────\r\n    useEffect(() => {\r\n        return () => {\r\n            stopHeartbeat();\r\n            if (seekDebounceRef.current) clearTimeout(seekDebounceRef.current);\r\n        };\r\n    }, [stopHeartbeat]);\r\n\r\n    return {\r\n        emitPlay,\r\n        emitPause,\r\n        emitSeek,\r\n        emitVolumeChange,\r\n        startHeartbeat,\r\n        stopHeartbeat,\r\n        roomTime,\r\n        roomDuration,\r\n        isSyncing: () => isSyncingRef.current,\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}