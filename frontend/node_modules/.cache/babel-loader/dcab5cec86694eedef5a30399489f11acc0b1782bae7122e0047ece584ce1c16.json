{"ast":null,"code":"var _s = $RefreshSig$();\n/**\r\n * useWebRTC.js  — Production-grade WebRTC hook\r\n *\r\n * ROOT CAUSES of the \"Sync Only / WebRTC failed\" on Vercel + Render:\r\n *\r\n *  BUG 1 — Double-offer race:\r\n *    In handleRequestStream the code manually called pc.createOffer() AND\r\n *    pc.onnegotiationneeded also fired (because addTrack triggers it).\r\n *    Two simultaneous offers → signaling state machine error → connection dies.\r\n *    FIX: Remove onnegotiationneeded entirely. All offers are created EXPLICITLY\r\n *    only in handleRequestStream and handleUserJoined.\r\n *\r\n *  BUG 2 — No TURN server:\r\n *    Locally both peers share the same machine → no NAT → STUN succeeds trivially.\r\n *    On Vercel + Render the viewer and host are on different networks behind NAT.\r\n *    If either side is behind symmetric NAT (common on mobile/corporate), STUN\r\n *    can't punch through → ICE fails → \"failed\" state.\r\n *    FIX: Add a free TURN server (openrelay.metered.ca) as built-in fallback.\r\n *    Users can override with their own TURN via env vars.\r\n *\r\n *  BUG 3 — handleUserJoined relied on onnegotiationneeded firing asynchronously\r\n *    but that was never guaranteed (esp. with the removed onnegotiationneeded handler).\r\n *    FIX: Explicitly create offer and send it in handleUserJoined, same as\r\n *    handleRequestStream.\r\n *\r\n * Architecture:\r\n *  - EXPLICIT negotiation only (no onnegotiationneeded)\r\n *  - Host is always offerer, viewer is always answerer\r\n *  - ICE candidates buffered until after setRemoteDescription\r\n *  - TURN servers included for NAT traversal in production\r\n *  - Full ICE state logging for debugging\r\n */\n\nimport { useRef, useState, useEffect, useCallback } from \"react\";\n\n// ─── ICE Configuration ────────────────────────────────────────────────────────\n// Free TURN servers: openrelay.metered.ca (no sign-up needed, testing only)\n// Replace with your own TURN server for production to avoid rate limits.\n// Metered.ca free tier: https://www.metered.ca/tools/openrelay/\nconst ICE_CONFIG = {\n  iceServers: [{\n    urls: \"stun:stun.l.google.com:19302\"\n  }, {\n    urls: \"stun:stun1.l.google.com:19302\"\n  }, {\n    urls: \"stun:stun2.l.google.com:19302\"\n  },\n  // ── Free TURN for testing (openrelay.metered.ca) ──\n  // These allow NAT traversal when STUN alone fails (production deployments)\n  {\n    urls: \"turn:openrelay.metered.ca:80\",\n    username: \"openrelayproject\",\n    credential: \"openrelayproject\"\n  }, {\n    urls: \"turn:openrelay.metered.ca:443\",\n    username: \"openrelayproject\",\n    credential: \"openrelayproject\"\n  }, {\n    urls: \"turn:openrelay.metered.ca:443?transport=tcp\",\n    username: \"openrelayproject\",\n    credential: \"openrelayproject\"\n  },\n  // ── Your own TURN (override via env vars for production) ──\n  ...(process.env.REACT_APP_TURN_URL ? [{\n    urls: process.env.REACT_APP_TURN_URL,\n    username: process.env.REACT_APP_TURN_USERNAME || \"\",\n    credential: process.env.REACT_APP_TURN_CREDENTIAL || \"\"\n  }] : [])],\n  iceCandidatePoolSize: 10,\n  bundlePolicy: \"max-bundle\",\n  rtcpMuxPolicy: \"require\"\n};\n\n// ─── Hook ─────────────────────────────────────────────────────────────────────\nexport function useWebRTC({\n  roomId,\n  socket\n}) {\n  _s();\n  const pcs = useRef({}); // { peerId: RTCPeerConnection }\n  const iceCandidateQueue = useRef({}); // { peerId: RTCIceCandidateInit[] }\n  const remoteDescSet = useRef({}); // { peerId: boolean }\n  const localStreamRef = useRef(null);\n  const makingOfferRef = useRef({}); // { peerId: boolean } — glare guard\n\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [peerStates, setPeerStates] = useState({});\n  const [usingFallback, setUsingFallback] = useState(false);\n\n  // ── ICE helper: queue until remote description is set ──────────────────────\n  const queueIceCandidate = useCallback((peerId, candidate) => {\n    if (!iceCandidateQueue.current[peerId]) {\n      iceCandidateQueue.current[peerId] = [];\n    }\n    iceCandidateQueue.current[peerId].push(candidate);\n  }, []);\n  const flushIceCandidates = useCallback(async peerId => {\n    const pc = pcs.current[peerId];\n    if (!pc) return;\n    const queue = iceCandidateQueue.current[peerId] || [];\n    iceCandidateQueue.current[peerId] = [];\n    console.log(`[WebRTC] Flushing ${queue.length} buffered ICE candidates for ${peerId}`);\n    for (const candidate of queue) {\n      try {\n        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n      } catch (err) {\n        // Benign — can happen if candidate is redundant or connection closed\n      }\n    }\n  }, []);\n\n  // ── Create RTCPeerConnection ───────────────────────────────────────────────\n  const createPeerConnection = useCallback(peerId => {\n    // Close any stale connection first\n    if (pcs.current[peerId]) {\n      console.log(`[WebRTC] Closing stale PC for ${peerId}`);\n      pcs.current[peerId].close();\n      delete pcs.current[peerId];\n    }\n    remoteDescSet.current[peerId] = false;\n    iceCandidateQueue.current[peerId] = [];\n    makingOfferRef.current[peerId] = false;\n    console.log(`[WebRTC] Creating RTCPeerConnection for ${peerId}`);\n    const pc = new RTCPeerConnection(ICE_CONFIG);\n    pcs.current[peerId] = pc;\n\n    // ── ICE candidate handler ─────────────────────────────────────────────\n    pc.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) {\n        console.log(`[ICE] Sending candidate to ${peerId}: ${candidate.type} ${candidate.protocol}`);\n        socket.emit(\"webrtc-ice-candidate\", {\n          to: peerId,\n          candidate\n        });\n      } else {\n        console.log(`[ICE] Gathering complete for ${peerId}`);\n      }\n    };\n    pc.onicegatheringstatechange = () => {\n      console.log(`[ICE] Gathering state → ${pc.iceGatheringState} (peer: ${peerId})`);\n    };\n\n    // ── ICE connection state — critical for debugging ────────────────────\n    pc.oniceconnectionstatechange = () => {\n      const s = pc.iceConnectionState;\n      console.log(`%c[ICE] Connection state → ${s} (peer: ${peerId})`, s === \"connected\" || s === \"completed\" ? \"color:green;font-weight:bold\" : s === \"failed\" ? \"color:red;font-weight:bold\" : \"color:orange\");\n      const normalized = s === \"connected\" || s === \"completed\" ? \"connected\" : s === \"failed\" || s === \"disconnected\" ? \"failed\" : \"connecting\";\n      setPeerStates(prev => ({\n        ...prev,\n        [peerId]: normalized\n      }));\n      if (s === \"failed\") {\n        console.error(`[ICE] FAILED for ${peerId}.\\n` + \"Possible causes:\\n\" + \"  1. No TURN server reached (symmetric NAT)\\n\" + \"  2. Firewall blocking UDP ports\\n\" + \"  3. ICE candidates dropped before setRemoteDescription\\n\" + \"Activating Socket.io-only fallback sync.\");\n        setUsingFallback(true);\n      }\n      if (s === \"disconnected\") {\n        // Try ICE restart before giving up\n        console.warn(`[ICE] Disconnected — attempting restart for ${peerId}`);\n        if (localStreamRef.current && pc.restartIce) {\n          pc.restartIce();\n        }\n      }\n    };\n    pc.onsignalingstatechange = () => {\n      console.log(`[SIG] Signaling state → ${pc.signalingState} (peer: ${peerId})`);\n    };\n    pc.onconnectionstatechange = () => {\n      console.log(`[PC] Connection state → ${pc.connectionState} (peer: ${peerId})`);\n    };\n\n    // ── Receive tracks from remote peer (viewer side) ─────────────────────\n    pc.ontrack = ({\n      track,\n      streams\n    }) => {\n      console.log(`[WebRTC] ontrack: kind=${track.kind} from ${peerId}`, streams);\n      if (!streams || streams.length === 0) {\n        console.warn(\"[WebRTC] ontrack fired with no streams — track without stream\");\n        return;\n      }\n      const incomingStream = streams[0];\n      setRemoteStream(prev => {\n        if (prev && prev.id === incomingStream.id) return prev; // no-op if same\n        console.log(`[WebRTC] Assigning remote stream ${incomingStream.id}`);\n        return incomingStream;\n      });\n    };\n\n    // IMPORTANT: Do NOT set onnegotiationneeded here.\n    // It was causing a race condition where both the automatic negotiation\n    // and our manual createOffer() ran simultaneously → signaling glare → failure.\n    // All offers are initiated EXPLICITLY below.\n\n    return pc;\n  }, [socket]);\n\n  // ── Helper: add all local tracks to a peer connection ─────────────────────\n  const addLocalTracks = useCallback(pc => {\n    const stream = localStreamRef.current;\n    if (!stream) return;\n    const existingSenderTrackIds = pc.getSenders().map(s => {\n      var _s$track;\n      return (_s$track = s.track) === null || _s$track === void 0 ? void 0 : _s$track.id;\n    }).filter(Boolean);\n    stream.getTracks().forEach(track => {\n      if (!existingSenderTrackIds.includes(track.id)) {\n        console.log(`[WebRTC] Adding track: ${track.kind} (${track.id})`);\n        pc.addTrack(track, stream);\n      }\n    });\n  }, []);\n\n  // ── Helper: explicitly create and send offer (HOST only) ──────────────────\n  const sendOffer = useCallback(async peerId => {\n    const pc = pcs.current[peerId];\n    if (!pc) return;\n    if (makingOfferRef.current[peerId]) {\n      console.warn(`[WebRTC] Already making offer for ${peerId}, skipping`);\n      return;\n    }\n    try {\n      makingOfferRef.current[peerId] = true;\n      console.log(`[WebRTC] Creating offer for ${peerId}`);\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: false,\n        // host sends only, not receives\n        offerToReceiveVideo: false\n      });\n      await pc.setLocalDescription(offer);\n      console.log(`[WebRTC] Sending offer to ${peerId}`);\n      socket.emit(\"webrtc-offer\", {\n        to: peerId,\n        offer: pc.localDescription\n      });\n    } catch (err) {\n      console.error(`[WebRTC] Failed to create offer for ${peerId}:`, err);\n    } finally {\n      makingOfferRef.current[peerId] = false;\n    }\n  }, [socket]);\n\n  // ── Public: host calls this when stream is ready ───────────────────────────\n  const startStream = useCallback(stream => {\n    console.log(\"[WebRTC] startStream — storing local stream\");\n    localStreamRef.current = stream;\n    // If any peer connections already exist (rare edge case), add tracks\n    Object.entries(pcs.current).forEach(([peerId, pc]) => {\n      addLocalTracks(pc);\n      sendOffer(peerId);\n    });\n  }, [addLocalTracks, sendOffer]);\n\n  // ── Public: stop all peer connections ─────────────────────────────────────\n  const stopStream = useCallback(() => {\n    console.log(\"[WebRTC] stopStream — closing all connections\");\n    Object.values(pcs.current).forEach(pc => pc.close());\n    pcs.current = {};\n    iceCandidateQueue.current = {};\n    remoteDescSet.current = {};\n    makingOfferRef.current = {};\n    localStreamRef.current = null;\n    setRemoteStream(null);\n    setPeerStates({});\n    setUsingFallback(false);\n  }, []);\n\n  // ── Socket event handlers ─────────────────────────────────────────────────\n  useEffect(() => {\n    if (!socket || !roomId) return;\n\n    // HOST receives: viewer is requesting the stream\n    const handleRequestStream = async ({\n      from\n    }) => {\n      console.log(`[WebRTC] ← request-stream from viewer ${from}`);\n      if (!localStreamRef.current) {\n        console.warn(\"[WebRTC] request-stream received but no local stream — ignoring\");\n        return;\n      }\n      const pc = createPeerConnection(from);\n      addLocalTracks(pc);\n      // Brief delay so addTrack settles before negotiation\n      await new Promise(r => setTimeout(r, 50));\n      await sendOffer(from);\n    };\n\n    // VIEWER receives: host sent an offer\n    const handleOffer = async ({\n      offer,\n      from\n    }) => {\n      console.log(`[WebRTC] ← offer from host ${from}`);\n\n      // Create/recreate PC for this host\n      const pc = createPeerConnection(from);\n      try {\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\n        remoteDescSet.current[from] = true;\n        console.log(`[WebRTC] Remote description set for ${from}`);\n\n        // Flush any ICE candidates that arrived early\n        await flushIceCandidates(from);\n        const answer = await pc.createAnswer();\n        await pc.setLocalDescription(answer);\n        console.log(`[WebRTC] Sending answer to ${from}`);\n        socket.emit(\"webrtc-answer\", {\n          to: from,\n          answer: pc.localDescription\n        });\n      } catch (err) {\n        console.error(`[WebRTC] Failed to handle offer from ${from}:`, err);\n      }\n    };\n\n    // HOST receives: viewer sent an answer\n    const handleAnswer = async ({\n      answer,\n      from\n    }) => {\n      console.log(`[WebRTC] ← answer from viewer ${from}`);\n      const pc = pcs.current[from];\n      if (!pc) {\n        console.warn(`[WebRTC] No PC found for ${from} when handling answer`);\n        return;\n      }\n      if (pc.signalingState !== \"have-local-offer\") {\n        console.warn(`[WebRTC] Unexpected signaling state \"${pc.signalingState}\" when handling answer from ${from}`);\n        return;\n      }\n      try {\n        await pc.setRemoteDescription(new RTCSessionDescription(answer));\n        remoteDescSet.current[from] = true;\n        console.log(`[WebRTC] Remote description (answer) set for ${from}`);\n        await flushIceCandidates(from);\n      } catch (err) {\n        console.error(`[WebRTC] Failed to handle answer from ${from}:`, err);\n      }\n    };\n\n    // BOTH: receive an ICE candidate from the other peer\n    const handleIceCandidate = async ({\n      candidate,\n      from\n    }) => {\n      if (!candidate) return;\n      const pc = pcs.current[from];\n      if (!pc) {\n        // PC might not exist yet — queue it anyway\n        console.log(`[ICE] No PC yet for ${from}, queuing candidate`);\n        queueIceCandidate(from, candidate);\n        return;\n      }\n      if (remoteDescSet.current[from]) {\n        // Remote description is set — apply immediately\n        try {\n          await pc.addIceCandidate(new RTCIceCandidate(candidate));\n          console.log(`[ICE] Applied candidate from ${from}: ${candidate.type}`);\n        } catch (err) {\n          // Only log if it's not a harmless benign error\n          if (!err.message.includes(\"Cannot add ICE candidate\")) {\n            console.warn(`[ICE] addIceCandidate error from ${from}:`, err.message);\n          }\n        }\n      } else {\n        // Remote description not set yet — MUST buffer\n        console.log(`[ICE] Buffering candidate from ${from} (remoteDesc not set yet)`);\n        queueIceCandidate(from, candidate);\n      }\n    };\n\n    // HOST receives: a NEW viewer just joined — send them an offer immediately \n    // (only if we are already streaming)\n    const handleUserJoined = async ({\n      id: newUserId\n    }) => {\n      if (!localStreamRef.current) return; // We're not the host\n      console.log(`[WebRTC] New viewer joined: ${newUserId} — sending offer proactively`);\n      const pc = createPeerConnection(newUserId);\n      addLocalTracks(pc);\n      await new Promise(r => setTimeout(r, 50));\n      await sendOffer(newUserId);\n    };\n\n    // Cleanup when a peer leaves\n    const handleUserLeft = ({\n      id: leftUserId\n    }) => {\n      console.log(`[WebRTC] User left: ${leftUserId} — closing PC`);\n      if (pcs.current[leftUserId]) {\n        pcs.current[leftUserId].close();\n        delete pcs.current[leftUserId];\n      }\n      delete remoteDescSet.current[leftUserId];\n      delete iceCandidateQueue.current[leftUserId];\n      delete makingOfferRef.current[leftUserId];\n      setPeerStates(prev => {\n        const next = {\n          ...prev\n        };\n        delete next[leftUserId];\n        return next;\n      });\n    };\n    socket.on(\"request-stream\", handleRequestStream);\n    socket.on(\"webrtc-offer\", handleOffer);\n    socket.on(\"webrtc-answer\", handleAnswer);\n    socket.on(\"webrtc-ice-candidate\", handleIceCandidate);\n    socket.on(\"user-joined\", handleUserJoined);\n    socket.on(\"user-left\", handleUserLeft);\n    return () => {\n      socket.off(\"request-stream\", handleRequestStream);\n      socket.off(\"webrtc-offer\", handleOffer);\n      socket.off(\"webrtc-answer\", handleAnswer);\n      socket.off(\"webrtc-ice-candidate\", handleIceCandidate);\n      socket.off(\"user-joined\", handleUserJoined);\n      socket.off(\"user-left\", handleUserLeft);\n    };\n  }, [socket, roomId, createPeerConnection, addLocalTracks, sendOffer, flushIceCandidates, queueIceCandidate]);\n\n  // ── Cleanup on unmount ────────────────────────────────────────────────────\n  useEffect(() => {\n    return () => stopStream();\n  }, [stopStream]);\n  return {\n    startStream,\n    stopStream,\n    remoteStream,\n    peerStates,\n    usingFallback,\n    isConnected: Object.values(peerStates).some(s => s === \"connected\")\n  };\n}\n_s(useWebRTC, \"TBciGXnRHueOrJFPblHu1+HhOJ8=\");","map":{"version":3,"names":["useRef","useState","useEffect","useCallback","ICE_CONFIG","iceServers","urls","username","credential","process","env","REACT_APP_TURN_URL","REACT_APP_TURN_USERNAME","REACT_APP_TURN_CREDENTIAL","iceCandidatePoolSize","bundlePolicy","rtcpMuxPolicy","useWebRTC","roomId","socket","_s","pcs","iceCandidateQueue","remoteDescSet","localStreamRef","makingOfferRef","remoteStream","setRemoteStream","peerStates","setPeerStates","usingFallback","setUsingFallback","queueIceCandidate","peerId","candidate","current","push","flushIceCandidates","pc","queue","console","log","length","addIceCandidate","RTCIceCandidate","err","createPeerConnection","close","RTCPeerConnection","onicecandidate","type","protocol","emit","to","onicegatheringstatechange","iceGatheringState","oniceconnectionstatechange","s","iceConnectionState","normalized","prev","error","warn","restartIce","onsignalingstatechange","signalingState","onconnectionstatechange","connectionState","ontrack","track","streams","kind","incomingStream","id","addLocalTracks","stream","existingSenderTrackIds","getSenders","map","_s$track","filter","Boolean","getTracks","forEach","includes","addTrack","sendOffer","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","localDescription","startStream","Object","entries","stopStream","values","handleRequestStream","from","Promise","r","setTimeout","handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleAnswer","handleIceCandidate","message","handleUserJoined","newUserId","handleUserLeft","leftUserId","next","on","off","isConnected","some"],"sources":["C:/Users/rohit/OneDrive/Desktop/SrtreamMovie/Movie-Party/frontend/src/hooks/useWebRTC.js"],"sourcesContent":["/**\r\n * useWebRTC.js  — Production-grade WebRTC hook\r\n *\r\n * ROOT CAUSES of the \"Sync Only / WebRTC failed\" on Vercel + Render:\r\n *\r\n *  BUG 1 — Double-offer race:\r\n *    In handleRequestStream the code manually called pc.createOffer() AND\r\n *    pc.onnegotiationneeded also fired (because addTrack triggers it).\r\n *    Two simultaneous offers → signaling state machine error → connection dies.\r\n *    FIX: Remove onnegotiationneeded entirely. All offers are created EXPLICITLY\r\n *    only in handleRequestStream and handleUserJoined.\r\n *\r\n *  BUG 2 — No TURN server:\r\n *    Locally both peers share the same machine → no NAT → STUN succeeds trivially.\r\n *    On Vercel + Render the viewer and host are on different networks behind NAT.\r\n *    If either side is behind symmetric NAT (common on mobile/corporate), STUN\r\n *    can't punch through → ICE fails → \"failed\" state.\r\n *    FIX: Add a free TURN server (openrelay.metered.ca) as built-in fallback.\r\n *    Users can override with their own TURN via env vars.\r\n *\r\n *  BUG 3 — handleUserJoined relied on onnegotiationneeded firing asynchronously\r\n *    but that was never guaranteed (esp. with the removed onnegotiationneeded handler).\r\n *    FIX: Explicitly create offer and send it in handleUserJoined, same as\r\n *    handleRequestStream.\r\n *\r\n * Architecture:\r\n *  - EXPLICIT negotiation only (no onnegotiationneeded)\r\n *  - Host is always offerer, viewer is always answerer\r\n *  - ICE candidates buffered until after setRemoteDescription\r\n *  - TURN servers included for NAT traversal in production\r\n *  - Full ICE state logging for debugging\r\n */\r\n\r\nimport { useRef, useState, useEffect, useCallback } from \"react\";\r\n\r\n// ─── ICE Configuration ────────────────────────────────────────────────────────\r\n// Free TURN servers: openrelay.metered.ca (no sign-up needed, testing only)\r\n// Replace with your own TURN server for production to avoid rate limits.\r\n// Metered.ca free tier: https://www.metered.ca/tools/openrelay/\r\nconst ICE_CONFIG = {\r\n    iceServers: [\r\n        { urls: \"stun:stun.l.google.com:19302\" },\r\n        { urls: \"stun:stun1.l.google.com:19302\" },\r\n        { urls: \"stun:stun2.l.google.com:19302\" },\r\n\r\n        // ── Free TURN for testing (openrelay.metered.ca) ──\r\n        // These allow NAT traversal when STUN alone fails (production deployments)\r\n        {\r\n            urls: \"turn:openrelay.metered.ca:80\",\r\n            username: \"openrelayproject\",\r\n            credential: \"openrelayproject\",\r\n        },\r\n        {\r\n            urls: \"turn:openrelay.metered.ca:443\",\r\n            username: \"openrelayproject\",\r\n            credential: \"openrelayproject\",\r\n        },\r\n        {\r\n            urls: \"turn:openrelay.metered.ca:443?transport=tcp\",\r\n            username: \"openrelayproject\",\r\n            credential: \"openrelayproject\",\r\n        },\r\n\r\n        // ── Your own TURN (override via env vars for production) ──\r\n        ...(process.env.REACT_APP_TURN_URL\r\n            ? [\r\n                {\r\n                    urls: process.env.REACT_APP_TURN_URL,\r\n                    username: process.env.REACT_APP_TURN_USERNAME || \"\",\r\n                    credential: process.env.REACT_APP_TURN_CREDENTIAL || \"\",\r\n                },\r\n            ]\r\n            : []),\r\n    ],\r\n    iceCandidatePoolSize: 10,\r\n    bundlePolicy: \"max-bundle\",\r\n    rtcpMuxPolicy: \"require\",\r\n};\r\n\r\n// ─── Hook ─────────────────────────────────────────────────────────────────────\r\nexport function useWebRTC({ roomId, socket }) {\r\n    const pcs = useRef({});                  // { peerId: RTCPeerConnection }\r\n    const iceCandidateQueue = useRef({});    // { peerId: RTCIceCandidateInit[] }\r\n    const remoteDescSet = useRef({});        // { peerId: boolean }\r\n    const localStreamRef = useRef(null);\r\n    const makingOfferRef = useRef({});       // { peerId: boolean } — glare guard\r\n\r\n    const [remoteStream, setRemoteStream] = useState(null);\r\n    const [peerStates, setPeerStates] = useState({});\r\n    const [usingFallback, setUsingFallback] = useState(false);\r\n\r\n    // ── ICE helper: queue until remote description is set ──────────────────────\r\n    const queueIceCandidate = useCallback((peerId, candidate) => {\r\n        if (!iceCandidateQueue.current[peerId]) {\r\n            iceCandidateQueue.current[peerId] = [];\r\n        }\r\n        iceCandidateQueue.current[peerId].push(candidate);\r\n    }, []);\r\n\r\n    const flushIceCandidates = useCallback(async (peerId) => {\r\n        const pc = pcs.current[peerId];\r\n        if (!pc) return;\r\n        const queue = iceCandidateQueue.current[peerId] || [];\r\n        iceCandidateQueue.current[peerId] = [];\r\n        console.log(`[WebRTC] Flushing ${queue.length} buffered ICE candidates for ${peerId}`);\r\n        for (const candidate of queue) {\r\n            try {\r\n                await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n            } catch (err) {\r\n                // Benign — can happen if candidate is redundant or connection closed\r\n            }\r\n        }\r\n    }, []);\r\n\r\n    // ── Create RTCPeerConnection ───────────────────────────────────────────────\r\n    const createPeerConnection = useCallback(\r\n        (peerId) => {\r\n            // Close any stale connection first\r\n            if (pcs.current[peerId]) {\r\n                console.log(`[WebRTC] Closing stale PC for ${peerId}`);\r\n                pcs.current[peerId].close();\r\n                delete pcs.current[peerId];\r\n            }\r\n            remoteDescSet.current[peerId] = false;\r\n            iceCandidateQueue.current[peerId] = [];\r\n            makingOfferRef.current[peerId] = false;\r\n\r\n            console.log(`[WebRTC] Creating RTCPeerConnection for ${peerId}`);\r\n            const pc = new RTCPeerConnection(ICE_CONFIG);\r\n            pcs.current[peerId] = pc;\r\n\r\n            // ── ICE candidate handler ─────────────────────────────────────────────\r\n            pc.onicecandidate = ({ candidate }) => {\r\n                if (candidate) {\r\n                    console.log(`[ICE] Sending candidate to ${peerId}: ${candidate.type} ${candidate.protocol}`);\r\n                    socket.emit(\"webrtc-ice-candidate\", { to: peerId, candidate });\r\n                } else {\r\n                    console.log(`[ICE] Gathering complete for ${peerId}`);\r\n                }\r\n            };\r\n\r\n            pc.onicegatheringstatechange = () => {\r\n                console.log(`[ICE] Gathering state → ${pc.iceGatheringState} (peer: ${peerId})`);\r\n            };\r\n\r\n            // ── ICE connection state — critical for debugging ────────────────────\r\n            pc.oniceconnectionstatechange = () => {\r\n                const s = pc.iceConnectionState;\r\n                console.log(`%c[ICE] Connection state → ${s} (peer: ${peerId})`,\r\n                    s === \"connected\" || s === \"completed\" ? \"color:green;font-weight:bold\"\r\n                        : s === \"failed\" ? \"color:red;font-weight:bold\"\r\n                            : \"color:orange\");\r\n\r\n                const normalized =\r\n                    s === \"connected\" || s === \"completed\" ? \"connected\"\r\n                        : s === \"failed\" || s === \"disconnected\" ? \"failed\"\r\n                            : \"connecting\";\r\n\r\n                setPeerStates((prev) => ({ ...prev, [peerId]: normalized }));\r\n\r\n                if (s === \"failed\") {\r\n                    console.error(\r\n                        `[ICE] FAILED for ${peerId}.\\n` +\r\n                        \"Possible causes:\\n\" +\r\n                        \"  1. No TURN server reached (symmetric NAT)\\n\" +\r\n                        \"  2. Firewall blocking UDP ports\\n\" +\r\n                        \"  3. ICE candidates dropped before setRemoteDescription\\n\" +\r\n                        \"Activating Socket.io-only fallback sync.\"\r\n                    );\r\n                    setUsingFallback(true);\r\n                }\r\n\r\n                if (s === \"disconnected\") {\r\n                    // Try ICE restart before giving up\r\n                    console.warn(`[ICE] Disconnected — attempting restart for ${peerId}`);\r\n                    if (localStreamRef.current && pc.restartIce) {\r\n                        pc.restartIce();\r\n                    }\r\n                }\r\n            };\r\n\r\n            pc.onsignalingstatechange = () => {\r\n                console.log(`[SIG] Signaling state → ${pc.signalingState} (peer: ${peerId})`);\r\n            };\r\n\r\n            pc.onconnectionstatechange = () => {\r\n                console.log(`[PC] Connection state → ${pc.connectionState} (peer: ${peerId})`);\r\n            };\r\n\r\n            // ── Receive tracks from remote peer (viewer side) ─────────────────────\r\n            pc.ontrack = ({ track, streams }) => {\r\n                console.log(`[WebRTC] ontrack: kind=${track.kind} from ${peerId}`, streams);\r\n                if (!streams || streams.length === 0) {\r\n                    console.warn(\"[WebRTC] ontrack fired with no streams — track without stream\");\r\n                    return;\r\n                }\r\n                const incomingStream = streams[0];\r\n                setRemoteStream((prev) => {\r\n                    if (prev && prev.id === incomingStream.id) return prev; // no-op if same\r\n                    console.log(`[WebRTC] Assigning remote stream ${incomingStream.id}`);\r\n                    return incomingStream;\r\n                });\r\n            };\r\n\r\n            // IMPORTANT: Do NOT set onnegotiationneeded here.\r\n            // It was causing a race condition where both the automatic negotiation\r\n            // and our manual createOffer() ran simultaneously → signaling glare → failure.\r\n            // All offers are initiated EXPLICITLY below.\r\n\r\n            return pc;\r\n        },\r\n        [socket]\r\n    );\r\n\r\n    // ── Helper: add all local tracks to a peer connection ─────────────────────\r\n    const addLocalTracks = useCallback((pc) => {\r\n        const stream = localStreamRef.current;\r\n        if (!stream) return;\r\n        const existingSenderTrackIds = pc.getSenders()\r\n            .map((s) => s.track?.id)\r\n            .filter(Boolean);\r\n\r\n        stream.getTracks().forEach((track) => {\r\n            if (!existingSenderTrackIds.includes(track.id)) {\r\n                console.log(`[WebRTC] Adding track: ${track.kind} (${track.id})`);\r\n                pc.addTrack(track, stream);\r\n            }\r\n        });\r\n    }, []);\r\n\r\n    // ── Helper: explicitly create and send offer (HOST only) ──────────────────\r\n    const sendOffer = useCallback(\r\n        async (peerId) => {\r\n            const pc = pcs.current[peerId];\r\n            if (!pc) return;\r\n            if (makingOfferRef.current[peerId]) {\r\n                console.warn(`[WebRTC] Already making offer for ${peerId}, skipping`);\r\n                return;\r\n            }\r\n            try {\r\n                makingOfferRef.current[peerId] = true;\r\n                console.log(`[WebRTC] Creating offer for ${peerId}`);\r\n                const offer = await pc.createOffer({\r\n                    offerToReceiveAudio: false,  // host sends only, not receives\r\n                    offerToReceiveVideo: false,\r\n                });\r\n                await pc.setLocalDescription(offer);\r\n                console.log(`[WebRTC] Sending offer to ${peerId}`);\r\n                socket.emit(\"webrtc-offer\", { to: peerId, offer: pc.localDescription });\r\n            } catch (err) {\r\n                console.error(`[WebRTC] Failed to create offer for ${peerId}:`, err);\r\n            } finally {\r\n                makingOfferRef.current[peerId] = false;\r\n            }\r\n        },\r\n        [socket]\r\n    );\r\n\r\n    // ── Public: host calls this when stream is ready ───────────────────────────\r\n    const startStream = useCallback(\r\n        (stream) => {\r\n            console.log(\"[WebRTC] startStream — storing local stream\");\r\n            localStreamRef.current = stream;\r\n            // If any peer connections already exist (rare edge case), add tracks\r\n            Object.entries(pcs.current).forEach(([peerId, pc]) => {\r\n                addLocalTracks(pc);\r\n                sendOffer(peerId);\r\n            });\r\n        },\r\n        [addLocalTracks, sendOffer]\r\n    );\r\n\r\n    // ── Public: stop all peer connections ─────────────────────────────────────\r\n    const stopStream = useCallback(() => {\r\n        console.log(\"[WebRTC] stopStream — closing all connections\");\r\n        Object.values(pcs.current).forEach((pc) => pc.close());\r\n        pcs.current = {};\r\n        iceCandidateQueue.current = {};\r\n        remoteDescSet.current = {};\r\n        makingOfferRef.current = {};\r\n        localStreamRef.current = null;\r\n        setRemoteStream(null);\r\n        setPeerStates({});\r\n        setUsingFallback(false);\r\n    }, []);\r\n\r\n    // ── Socket event handlers ─────────────────────────────────────────────────\r\n    useEffect(() => {\r\n        if (!socket || !roomId) return;\r\n\r\n        // HOST receives: viewer is requesting the stream\r\n        const handleRequestStream = async ({ from }) => {\r\n            console.log(`[WebRTC] ← request-stream from viewer ${from}`);\r\n\r\n            if (!localStreamRef.current) {\r\n                console.warn(\"[WebRTC] request-stream received but no local stream — ignoring\");\r\n                return;\r\n            }\r\n\r\n            const pc = createPeerConnection(from);\r\n            addLocalTracks(pc);\r\n            // Brief delay so addTrack settles before negotiation\r\n            await new Promise((r) => setTimeout(r, 50));\r\n            await sendOffer(from);\r\n        };\r\n\r\n        // VIEWER receives: host sent an offer\r\n        const handleOffer = async ({ offer, from }) => {\r\n            console.log(`[WebRTC] ← offer from host ${from}`);\r\n\r\n            // Create/recreate PC for this host\r\n            const pc = createPeerConnection(from);\r\n\r\n            try {\r\n                await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n                remoteDescSet.current[from] = true;\r\n                console.log(`[WebRTC] Remote description set for ${from}`);\r\n\r\n                // Flush any ICE candidates that arrived early\r\n                await flushIceCandidates(from);\r\n\r\n                const answer = await pc.createAnswer();\r\n                await pc.setLocalDescription(answer);\r\n                console.log(`[WebRTC] Sending answer to ${from}`);\r\n                socket.emit(\"webrtc-answer\", { to: from, answer: pc.localDescription });\r\n            } catch (err) {\r\n                console.error(`[WebRTC] Failed to handle offer from ${from}:`, err);\r\n            }\r\n        };\r\n\r\n        // HOST receives: viewer sent an answer\r\n        const handleAnswer = async ({ answer, from }) => {\r\n            console.log(`[WebRTC] ← answer from viewer ${from}`);\r\n            const pc = pcs.current[from];\r\n            if (!pc) {\r\n                console.warn(`[WebRTC] No PC found for ${from} when handling answer`);\r\n                return;\r\n            }\r\n\r\n            if (pc.signalingState !== \"have-local-offer\") {\r\n                console.warn(\r\n                    `[WebRTC] Unexpected signaling state \"${pc.signalingState}\" when handling answer from ${from}`\r\n                );\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n                remoteDescSet.current[from] = true;\r\n                console.log(`[WebRTC] Remote description (answer) set for ${from}`);\r\n                await flushIceCandidates(from);\r\n            } catch (err) {\r\n                console.error(`[WebRTC] Failed to handle answer from ${from}:`, err);\r\n            }\r\n        };\r\n\r\n        // BOTH: receive an ICE candidate from the other peer\r\n        const handleIceCandidate = async ({ candidate, from }) => {\r\n            if (!candidate) return;\r\n\r\n            const pc = pcs.current[from];\r\n            if (!pc) {\r\n                // PC might not exist yet — queue it anyway\r\n                console.log(`[ICE] No PC yet for ${from}, queuing candidate`);\r\n                queueIceCandidate(from, candidate);\r\n                return;\r\n            }\r\n\r\n            if (remoteDescSet.current[from]) {\r\n                // Remote description is set — apply immediately\r\n                try {\r\n                    await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n                    console.log(`[ICE] Applied candidate from ${from}: ${candidate.type}`);\r\n                } catch (err) {\r\n                    // Only log if it's not a harmless benign error\r\n                    if (!err.message.includes(\"Cannot add ICE candidate\")) {\r\n                        console.warn(`[ICE] addIceCandidate error from ${from}:`, err.message);\r\n                    }\r\n                }\r\n            } else {\r\n                // Remote description not set yet — MUST buffer\r\n                console.log(`[ICE] Buffering candidate from ${from} (remoteDesc not set yet)`);\r\n                queueIceCandidate(from, candidate);\r\n            }\r\n        };\r\n\r\n        // HOST receives: a NEW viewer just joined — send them an offer immediately \r\n        // (only if we are already streaming)\r\n        const handleUserJoined = async ({ id: newUserId }) => {\r\n            if (!localStreamRef.current) return; // We're not the host\r\n            console.log(`[WebRTC] New viewer joined: ${newUserId} — sending offer proactively`);\r\n            const pc = createPeerConnection(newUserId);\r\n            addLocalTracks(pc);\r\n            await new Promise((r) => setTimeout(r, 50));\r\n            await sendOffer(newUserId);\r\n        };\r\n\r\n        // Cleanup when a peer leaves\r\n        const handleUserLeft = ({ id: leftUserId }) => {\r\n            console.log(`[WebRTC] User left: ${leftUserId} — closing PC`);\r\n            if (pcs.current[leftUserId]) {\r\n                pcs.current[leftUserId].close();\r\n                delete pcs.current[leftUserId];\r\n            }\r\n            delete remoteDescSet.current[leftUserId];\r\n            delete iceCandidateQueue.current[leftUserId];\r\n            delete makingOfferRef.current[leftUserId];\r\n            setPeerStates((prev) => {\r\n                const next = { ...prev };\r\n                delete next[leftUserId];\r\n                return next;\r\n            });\r\n        };\r\n\r\n        socket.on(\"request-stream\", handleRequestStream);\r\n        socket.on(\"webrtc-offer\", handleOffer);\r\n        socket.on(\"webrtc-answer\", handleAnswer);\r\n        socket.on(\"webrtc-ice-candidate\", handleIceCandidate);\r\n        socket.on(\"user-joined\", handleUserJoined);\r\n        socket.on(\"user-left\", handleUserLeft);\r\n\r\n        return () => {\r\n            socket.off(\"request-stream\", handleRequestStream);\r\n            socket.off(\"webrtc-offer\", handleOffer);\r\n            socket.off(\"webrtc-answer\", handleAnswer);\r\n            socket.off(\"webrtc-ice-candidate\", handleIceCandidate);\r\n            socket.off(\"user-joined\", handleUserJoined);\r\n            socket.off(\"user-left\", handleUserLeft);\r\n        };\r\n    }, [\r\n        socket,\r\n        roomId,\r\n        createPeerConnection,\r\n        addLocalTracks,\r\n        sendOffer,\r\n        flushIceCandidates,\r\n        queueIceCandidate,\r\n    ]);\r\n\r\n    // ── Cleanup on unmount ────────────────────────────────────────────────────\r\n    useEffect(() => {\r\n        return () => stopStream();\r\n    }, [stopStream]);\r\n\r\n    return {\r\n        startStream,\r\n        stopStream,\r\n        remoteStream,\r\n        peerStates,\r\n        usingFallback,\r\n        isConnected: Object.values(peerStates).some((s) => s === \"connected\"),\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}